=pod

=head1 Planned functionality

=head2 Documentation

Documentation is likely incomplete, but has also gotten a bit more complex as configuration options become supported (sorry).

=head2 Script timestamps option

(Available with 0.1.3)  C<schedule-easing.pl --timestamps> should work.  It is currently available but not fully tested.  See notes in L<Schedule::Easing/"Timestamp Discovery">.

=head2 Relaxing, reducing, decreasing messages over time is experimental

(Available with 0.1.4) Behavior when C<beginE<gt>final> is partially tested.  Documentation may be incomplete.

=head2 Power and Step inverses are experimental

The functions have not been tested with the C<timestamps> calculations.

=head2 Timestamp support in Block

The C<block> type is currently universal.  It may be useful to have a scheduled blocking event that starts at C<tsA>, or that concludes at C<tsB>, or both.

=head2 Pass type

Support C<type=pass> that always includes a matching message.  Will help with faster bailout and to avoid unexpected matching against later easing configurations.

=head1 To Review

=head2 C<Schedule::Easing::Stream>, C<alarm()>, and C<clock>

See the comment about the single-use alarm() and how the C<clock> setting overlaps with the timing of batch processing.

=head2 Item weighting

All line/messages have the same weight.  Message weighting may be a property of content on the line itself, however.  Proposed to collect weights with a regexp, and use a configured total weight for scheduling.  This would be separate than a function, though it may be implemented as a score modification function per line.

=head2 Value gaps

Both MD5 and Numeric can suffer from notable value gaps.  Currently that requires separate configurations.

=head2 Sets and rolling windows

This library isn't designed for ongoing rotation though I<sets of names>, such as oncall rotations or words, such as the names of the days of the week.  Rolling MD5/numeric windows are also not supported at this time (the first 10%, the second 10%, the third 10%, ...).  Preselection via modular arithmetic is a much simpler solution, though it may be beneficial in the long term to support such behavior within a unified configuration.  Additional examples are needed before considering this as an easing option.

=head2 Rolling expanding windows

Windows of the form 1, 2, 3, ..., followed by "1 and 2", then "2 and 3", ..., then "1 and 2 and 3".  These can likely be achieved with MD5 using multiple digest captures.  Additional examples are needed before considering this as an easing option.

=cut
